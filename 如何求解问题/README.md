#### 7-11连锁店商品价格：如何缩小解的空间
* 问题：已知四种商品价格之和，之乘积皆为7.11美元，且商品最小价格不低于0.01美元。求四种商品各自价格
* 求解步骤
1. 确定变量域：初步缩小解的空间
由每件商品最小价格不低于0.01美元，可知每件商品最大价格为7.08美元，为避免处理小数，采用美分为计数单位。从而得到整数集合的变量域
{0.01,0.02,0.03...7.08}
2. 由因子分解入手：大大减小解的空间
由1得：
```
x+y+z+t=711
xyzt=711000000=2^6*3^2*5^6*79
```
则可知其中一件商品的价格能被79整除
3. 分情况讨论：消去不可能解
假设能被79整除的商品价格为x
1) x=79*1
则 y+z+t=632;yzt=2^6*3^2*5^6
2) x=79*2
则 y+z+t=553;yzt=2^5*3^2*5^6
......
由几个价格间的数学关系可得到最终的解
```
x=316
y=125
z=120
t=150
```


#### 第三章主要内容
1. 搜索空间最优解的传统方法分类
2. 介绍穷举搜索
3. 介绍枚举在SAT问题，TSP问题，NLP问题中的应用
4. 介绍局部搜索
5. SAT问题中的局部搜索

#### 搜索空间最优解的传统方法（经典优化算法）
* 仅评估完整解的算法
1. 包括穷举搜索，局部搜索，爬山法，基于梯度的数值优化方法；模拟退火，禁忌搜索，演化算法
2. 在这些算法执行时的任何一次迭代中，都可以打断并获取一个潜在解
*  需要评估部分解算法
1. 包括贪心算法，动态规划算法，分枝定界法
2. 部分解：原始问题的不完整解，或简化问题后的完整解
3. 处理部分解的难点
如何创造新的评估函数来评价部分解的质量？
如何将解空间组织成若干个能高效搜索的子空间？
* 二者的区别
1. 在仅评估完整解的算法中，评估函数只评估完整的一个解。而在评估部分解算法中，评估函数评估的是部分解。
2. 在仅评估完整解的算法中，最优解的产生方式是迭代更新。而在评估部分解算法中，最优解的产生方式是组合子问题的解

#### 穷举搜索
* 定义
> 检查搜索空间中的每一个解直至找到最好的全局解。“穷举”的意义在于，只有找遍搜索空间的每一处，才能确认已经找到最优解
* 缺点
由于搜索空间巨大，搜索耗时。比如TSP问题中，当城市规模达到50时，共需要穷举10^62条不同路径
* 优点
原理简单：系统地产生问题的每一个可能解。然后用评估函数实现最优解的迭代

#### 枚举SAT问题
枚举包含n个变量的SAT问题的搜索空间，步骤如下
1. 确立表达方式
产生长度为n的所有二进制串
2. 确立评估函数
串满足符合布尔表达式，则评估函数值为1；否则为0。一旦评估函数为1，则停止搜索
3. 更新最优解
依次给每个二进制串加上二进制1。每产生一个新串，就对其进行评估，得分最好的串作为当前最优解
4. 采用深度优先搜索来减少搜索空间
原理是将解空间按照变量取真还是假分成两个子空间，最终将整个解空间组织成树状结构。

图P44-3.1

深度优先搜索通过检查给定节点（即子空间）是否包含解，来避免不需要的沿枝搜索。

p45-x1,x2,x3,x4

#### 枚举TSP问题
* 如何设置评估函数：有些城市之间并不相同，其排列为非法，面对非法排列，该如何评估？
对于非法排列，在评估函数中设置高惩罚值。

#### 枚举NLP问题
* 表达方式：区间
用区间单元描述可能解。例如要找函数f(x1,x2)的最大值，且已知x1范围为[-1,3]。可以将x1的取值范围分为400个区间，每个区间单元长度为0.01，x2同理。搜索解空间的过程即穷举搜索单元的过程。一旦选出了具有最好评估价值的单元，就在该单元内继续划分区间。
* “粒度”（区间单元）问题
1. 粒度过大：搜索层次过粗，难以找到最优解
2. 粒度过小：单元数过大。


#### 局部搜索
* 与穷举搜索的不同（改进）
1. 穷举搜索是对整个解空间的每一处进行搜索，而局部搜索只针对某个特定解的局部领域展开搜索。
2. 穷举搜索能找到全局最优解，而局部搜索可能陷于局部最优解
* 步骤
1. 从搜索空间中找到一个解并评估其质量，将它定义为当前解
2. 找新解，若质量好于当前解，则替换；否则抛弃
3. 重复2直至在给定集中找不到更优解
* 极端情况
1. 随机均匀地从搜索空间中选择潜在解，此时局部搜索实质为枚举搜索。且由于随机性，可能重复选取已经试过的点
2. 变换的结果总是返回当前解，使搜索毫无进展
* 正确的方法（折衷）
在当前解的某个局部邻域范围内搜索下一个解。
* 局部搜索的关键：解的变换类型（决定邻域的大小）
1. 邻域过大：搜索效率下降，但不太会陷入局部最优解
2. 邻域过小：能够快速搜索该邻域，但可能陷入局部最优解 

#### SAT问题中的局部搜索（局部搜索效果很好）
* GSAT算法
p49 图3.5
* GSAT算法的主要思想
可满足子句个数：举例，若范式A且B且C满足A为真,B为真，C为假，则称ABC的可满足字句个数为2。显然，对于最优解的范式，其可满足子句个数应该等于该范式的子句个数
1. 从一个随机的真值指派开始，
2.连续反位每个变量的值（真变假，假变真）
3. 评估函数的评估依据是，每次取反后不满足子句个数的减少值。所以当前最优解总是使得不满足子句减少到最大
4. 当新产生的解满足问题时，算法终止，否则重复2、3过程
* “高原”陷阱
在SAT问题的局部搜索算法中,当前解的领域是改变该范式的一个变量的值能到达的所有赋值。那么很可能存在这样一种情况：领域中的每个值都比当前解满足更少的字句，也就是说当前解已经是局部最优解，我们称为“高原”。一些实验表明，当我们在GSAT的高原上进行搜索时，可能无法跳离“局部最优解”
* 改进
1. 为变量取反后的子句额外赋权值，不满足子句的权值较高，多次尝试都未被满足的子句权值尤其高。以此增加跳离“局部最优解”的机会
2. 提出用初始概率的方法对局部搜索算法中变量的初始随机指派进行适当的约束，使在局部搜索的开始阶段，可满足的子句数大大增加，减少了翻转的次数，加快了求解的速度

#### 第四章主要内容
1. 贪婪算法介绍
2. 贪婪算法和SAT问题
3. 贪婪算法和TSP问题
4. 分治算法
5. 动态规划算法

#### 贪婪算法
* 最优子结构性质
当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质。
* 优点
思路足够简单：总是在每一步选择那些能带来当前最大收益的变量，以此为作为当前最佳决定。
* 局限性
每一步作出最佳决定并不一定最终能得到全局最优解。而且许多情况下，我们通常事先不清楚这一点，只有通过实践，举反例才能发现贪婪算法对于某一种问题并不其效果。

#### 贪婪算法和SAT问题
想对SAT问题使用贪心算法，必须考虑到SAT问题的特性。
* 思路一
在之前的讨论中，我们已有一个结论：SAT问题的解应该能保证该范式的所有子句皆能被满足。那么，可不可以这么考虑：每一步，让算法能尽量满足最大数目地当前未满足子句。具体来说：
> 对从1到n的每个变量，不分选择先后顺序，每次指定一个为其派值，使得结果能尽可能地满足最大数目地当前未满足子句。如果不分胜负，则随机选择。
这种贪婪算法地性能很低，比如对于如下例子。贪婪算法会在一开始就选择为x1派值为真，这样一次能满足三个未满足子句，而x2,x3,x4却无此效果。但是这种所谓的“最优选择”却会导致第一个子句不可能被满足，所以之后的算法便是无用功了。
P66 例子
* 思路二
总结思路一的缺陷，会发现思路一的贪婪算法忽略了变量的选择次序。x1在每个子句中都有分布，一开始就选择它，很容易牵一发而动全身。于是我们改变思路。先考虑那些在少数几个子句中出现的变量（比如x2,x3,x4），后考虑经常出现的变量（如x1）。具体来说：
1. 将所有变量按照它们在所有子句中出现的顺序，从小到大进行排序。
2. 按照上面次序，对每个变量进行赋值，使得赋值结果能最大数目的满足当前未满足子句。
3. 如果有多种赋值使得满足子句数目相同，则随机选择一个。
经过实践，发现这种改经后的算法仍有不足之处。比如对于如下例子，假定公式F不包含x1和x2，但其余变量都在F中频繁出现。这样，x1出现在三个子句中，x2出现在四个子句中，其余变量出现频率远高于它们。那么贪婪算法会优先选择为x1赋值，并赋值为真以此满足第1，2两个子句。之后，x2会被赋值为真以满足第5,6两个子句。然后，这两次赋值结束后，我们会发现，第3，第4子句不可能同时满足，那么算法自然也不可能找到我们想要的解。
* 其它思路
1. 引入特别的规定，禁止所有使得某个子句为FALSE的变量取值。
2. 增加新权重，比如在较短子句中出现的变量比在长子句中出现的变量具有更大的权重。
实践证明，这些方法都无法得到一个适合于所有SAT问题的算法。事实上根本找不到一个解决SAT问题的贪婪算法！

#### 贪婪算法与TSP问题
* 思路一
TSP问题的关键在于经过“所有”的城市和旅程“最短”。由此我们很容易想到贪婪算法的思路：随机从某个城市出发，前往最近的未被访问的城市，一直到所有的城市都被访问过且仅被访问一次，最后返回初始城市
* 反例
书P67 图4.1
从城市A开始，按照贪婪算法构造的路径为A->B->C->D->A，总费用为2+3+23+5=33，而路径A->C->B->D->A的费用仅为4+3+7+5=19
* 思路二
考虑每一步尽量使得新加入的边最小。具体来说，首先从每对城市之间的有效连接中找出费用最小的有效连接，然后再找下一个费用最小的有效连接，依次进行下去。
* 反例
书P67 图4.1
按照如上思路，这种贪婪算法首先找到A-B，再找B-C，再找A-D，最后是C-D。其结果与思路一结果相同，不是最优解。
* 结论
对于每一种能想出的常识性启发规则，都能找出一个特例使得这种规则看上去非常愚蠢。

#### 分而治之法
* 思想
将原问题划分成n个规模较小而结构与原问题相似的子问题；递归地解决这些子问题，然后再合并其结果，就得到原问题的解。
* 步骤
分治模式在每一层递归上都有三个步骤：
1. 分解(Divide)：将原问题分解成一系列子问题；
2. 解决(Conquer)：递归地解决各个子问题。若子问题足够小，则直接求解。
3. 合并(Combine)：将子问题的结果合并成原问题的解。
* 举例
合并排序(Merge Sort)是一个典型分治法的例子。其对应的直观的操作如下:
1. 分解： 将n个元素分成各含n/2个元素的子序列；
2. 解决：用合并排序法对两个子序列递归地排序；
3. 合并：合并两个已排序的子序列以得到排序结果。
* 缺陷
面对公共的子问题，若用分治法则会做许多不必要的工作，即重复地求解公共的子问题。
#### 动态规划法
* 特点
1. 具有最优子结构（整个问题的求解可以划分为若干个阶段的一系列决策过程）
2. 存在公共子问题，又称重叠子问题（动态规划算法会记录子问题的解，来避免下次遇到相同问题时的重复计算）







